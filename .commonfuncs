UNAME=$(uname)

makeMeLaugh() {
  local output width term_width

  if ! checkPath fortune; then
    echo "No fortunes for you!"
    return 0
  fi

  width=72
  term_width=$(tput cols)
  if [ "$term_width" -lt "$width" ]; then
      width=$((term_width - 5))
  fi

  # display the fortune requested
  if [ -n "$1" ]; then
      output=$(fortune -e "$1")
  # try to run my custom comedy folder of goodness
  elif [ -d /opt/local/share/games/fortune/comedy ] ||
       [ -d /usr/share/games/fortune/comedy ] ||
       [ -d /usr/share/games/fortunes/comedy ] ||
       [ -d /usr/share/fortune/comedy ] ||
       [ -d /usr/local/share/games/fortunes/comedy ]; then
      output=$(fortune -e comedy)
  # otherwise just any old fortune will do
  else
      output=$(fortune -a)
  fi

  # Spice it up if we can
  if checkPath cowthink; then
      output=$(cowthink -d -W "$width" "$output")
  fi

  echo -e "\n$output\n"
}

lulz() {
  local VOICE
  local msg
  local comedian

  while getopts "v:" OPTION
  do
       case $OPTION in
           v)
               VOICE=$OPTARG
               shift $((OPTIND-1))
               ;;
           ?)
               echo "Not a valid option"
               exit 1
               ;;
       esac
  done

  if [ -z "$VOICE" ]; then
      VOICE="Fred"
  fi

  msg="I cannot make you have lulz"
  if checkPath fortune && checkPath say; then
    if [ -n "$1" ]; then
        comedian="$1"
    elif [ -d /opt/local/share/games/fortune/comedy_short ]; then
        comedian=comedy_short
    else
        echo $msg
    fi
    if [ -n "$comedian" ]; then
        # pipe through sed to get rid of the attribution line, then say it
        fortune $comedian | sed -E '$,/^(-{1,2} |Deep Thoughts)/d' | say -v $VOICE
    fi
  else
    echo $msg
  fi
}

# helper function to search the $PATH for a given
# executable.  useful for checks across different
# systems.
checkPath() {
    which $1 &>/dev/null
}

isiPhone() {
    if checkPath sw_vers; then
        [ $(sw_vers | awk '/ProductName/ {print $2}') = "iPhone" ] && return 0
    fi
    return 1
}

# a little function to print the full path to a file.
fullpath() {
    local fullpath
    fullpath=$(pwd)/$1
    echo -n "\"$fullpath\""
    
    # on OS X copy it to the clipboard too :)
    if checkPath pbcopy && [ $UNAME = "Darwin" ]; then
        echo -n "\"$fullpath\"" | pbcopy
    fi

    # on linux use xclip to copy to the clipboard
    checkPath xclip && echo -n "\"$fullpath\"" | xclip
}

weShouldUpdate() {
    local time_to_update
    local time_marker
    local last_mod
    local current_time
    local time_diff
    # only update once a day
    time_to_update=86400
    # use a dot file as a marker
    time_marker="$HOME/.dotfiles"
    # if the file doesn't exist we'll end up touching it
    last_mod=0
    if [ -e $touchy_file ]; then
        # stat is different between flavas
        if [ $UNAME = "Linux" ] || isiPhone; then
            last_mod=$(stat -c %Y "$time_marker")
        elif [ $UNAME = "FreeBSD" ] || [ $UNAME = "Darwin" ]; then
            last_mod=$(stat -f %a "$time_marker")
        fi
    fi
    current_time=$(date +%s)
    # see what the difference is in seconds
    time_diff=$(( $current_time - $last_mod ))
    if [ $time_diff -gt $time_to_update ]; then
        touch "$time_marker"
        echo "It's been a while since we updated the dotfiles..."
        return 0
    fi
    return 1
}

search_movies() {
    local movies
    movies=`/Applications/Plex\ Media\ Server.app/Contents/MacOS/Plex\ Media\ Scanner -l -c 1 | awk -F: '{print $2}'`
    echo $movies | grep -i $1
}

tmh() {
    [[ -z "$1" ]] && echo 'project name is required' && return 1
    local location
    export T_PROJ=$1
    [[ -z "$2" ]] && location=local || location="$2"
    if [[ -n "$3" ]]; then
        export T_BUILD="$3"
    fi
    if [[ -n "$4" ]]; then
        export T_PREFIX="$4"
    fi
    teamocil --here $location
}

# Git stash + fzf = awesome
stache() {
    which fzf &>/dev/null || (echo "fzf is not installed. Install it and try again"; return)

    local stash stashes stash_choices action opts show_all choice_count prev_action prev_choices

    while getopts "a" OPTION; do
      case $OPTION in
        a) show_all="yes";;
      esac
    done

    while true; do
        # Get our list of stashes, cleaned up for human consumption
        stashes=$(git stash list | sed -Ee 's/^stash@\{([^}]+)\}: (.*)/[\1] \2/')
        if [[ -z "$show_all" ]]; then
            # get only named stashes, this is the default
            stashes=$(echo $stashes | grep -v WIP | sed -Ee 's/On [^:]+: //')
        fi

        stash_choices=$(echo $stashes | fzf -m -q "$prev_choices" --header="::::> choose a stash <::::$prev_action")
        prev_choices=''
        [[ $? -gt 0 ]] && return
        stash_choices=$(echo $stash_choices | sed -En 's/\[(.*)\].*/\1/p')

        # TODO: Ask for confirmation on destructive actions
        action=$(echo "quit\nshow\napply\npop\ndrop" | fzf --header='::::> choose an action <::::')

        # Bail out
        [[ $? -gt 0 ]] && return
        [[ "$action" == "quit" ]] && return

        # Set extra options
        if [[ "$action" == "show" ]]; then
            opts='-p'
            prev_choices=$(echo "$stash_choices" | sed -Ee 's/(.*)/^[\1] |/' | tr '\n' ' ' | sed 's/| $//')
        fi

        # Summary for the next round
        choice_count=$(echo "$stash_choices" | wc -l | sed 's/ //g')
        prev_action=$(echo "\n\n$action $choice_count item(s) complete")

        # Loop over the selected items and perform the action
        while read -r stash; do
            git stash $action $opts stash@\{$stash\} || return
        done <<< "$stash_choices"

        # clear out opts that were set
        opts=''
    done
}
