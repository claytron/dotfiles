# shellcheck shell=bash

makeMeLaugh() {
    local output width term_width

    if ! checkPath fortune; then
        echo "No fortunes for you!"
        return 0
    fi

    width=72
    term_width=$(tput cols)
    if [ "$term_width" -lt "$width" ]; then
        width=$((term_width - 5))
    fi

    # display the fortune requested
    if [ -n "$1" ]; then
        output=$(fortune -e "$1")
    elif [ -d "$HOME/.fortunes" ]; then
        output=$(fortune -e "$HOME/.fortunes")
    # try to run my custom comedy folder of goodness
    elif [ -d /opt/local/share/games/fortune/comedy ] ||
      [ -d /usr/share/games/fortune/comedy ] ||
      [ -d /usr/share/games/fortunes/comedy ] ||
      [ -d /usr/share/fortune/comedy ] ||
      [ -d /usr/local/share/games/fortunes/comedy ]; then
         output=$(fortune -e comedy)
    # otherwise just any old fortune will do
    else
        output=$(fortune -a)
    fi

    # Spice it up if we can
    if checkPath cowthink; then
        output=$(cowthink -d -W "$width" "$output")
    fi

    echo -e "\n$output\n"
}

lulz() {
    local VOICE
    local msg
    local comedian

    while getopts "v:" OPTION
    do
        case $OPTION in
            v)
                VOICE=$OPTARG
                shift $((OPTIND-1))
                ;;
            ?)
                echo "Not a valid option"
                exit 1
                ;;
        esac
    done

    if [ -z "$VOICE" ]; then
        VOICE="Fred"
    fi

    msg="I cannot make you have lulz"
    if checkPath fortune && checkPath say; then
        if [ -n "$1" ]; then
            comedian="$1"
        elif [ -d /opt/local/share/games/fortune/comedy_short ]; then
            comedian=comedy_short
        else
            echo "$msg"
        fi
        if [ -n "$comedian" ]; then
            # pipe through sed to get rid of the attribution line, then say it
            fortune $comedian | sed -E '$,/^(-{1,2} |Deep Thoughts)/d' | say -v $VOICE
        fi
    else
        echo "$msg"
    fi
}

# helper function to search the $PATH for a given
# executable.  useful for checks across different
# systems.
checkPath() {
    which "$1" &>/dev/null
}

weShouldUpdate() {
    local time_to_update
    local time_marker
    local last_mod
    local current_time
    local time_diff
    # only update once a day
    time_to_update=86400
    # use a dot file as a marker
    time_marker="$HOME/.dotfiles"
    # if the file doesn't exist we'll end up touching it
    last_mod=0
    # stat is different between flavas
    case $(uname) in
        Linux) last_mod=$(stat -c %Y "$time_marker") ;;
        FreeBSD|Darwin) last_mod=$(stat -f %a "$time_marker") ;;
    esac
    current_time=$(date +%s)
    # see what the difference is in seconds
    time_diff=$(( current_time - last_mod ))
    if [ $time_diff -gt $time_to_update ]; then
        touch "$time_marker"
        echo "It's been a while since we updated the dotfiles..."
        return 0
    fi
    return 1
}

# Git stash + fzf = awesome
stache() {
    which fzf &>/dev/null || (echo "fzf is not installed. Install it and try again"; return)

    local stash stashes stash_choices action opts show_all choice_count prev_action prev_choices

    while getopts "a" OPTION; do
        case $OPTION in
            a) show_all="yes";;
        esac
    done

    while true; do
        # Get our list of stashes, cleaned up for human consumption
        stashes=$(git stash list | sed -Ee 's/^stash@\{([^}]+)\}: (.*)/[\1] \2/')
        if [[ -z "$show_all" ]]; then
            # get only named stashes, this is the default
            stashes=$(echo "$stashes" | grep -v WIP | sed -Ee 's/On [^:]+: //')
        fi

        stash_choices=$(echo "$stashes" | fzf -m -q "$prev_choices" --header="::::> choose a stash <::::$prev_action")
        prev_choices=''
        [[ $? -gt 0 ]] && return
        stash_choices=$(echo "$stash_choices" | sed -En 's/\[(.*)\].*/\1/p')

        # TODO: Ask for confirmation on destructive actions
        action=$(echo "quit\nshow\napply\npop\ndrop" | fzf --header='::::> choose an action <::::')

        # Bail out
        [[ $? -gt 0 ]] && return
        [[ "$action" == "quit" ]] && return

        # Set extra options
        if [[ "$action" == "show" ]]; then
            opts='-p'
            prev_choices=$(echo "$stash_choices" | sed -Ee 's/(.*)/^[\1] |/' | tr '\n' ' ' | sed 's/| $//')
        fi

        # Summary for the next round
        choice_count=$(echo "$stash_choices" | wc -l | sed 's/ //g')
        prev_action=$(echo "\n\n$action $choice_count item(s) complete")

        # Loop over the selected items and perform the action
        while read -r stash; do
            git stash "$action" "$opts" stash@\{"$stash"\} || return
        done <<< "$stash_choices"

        # clear out opts that were set
        opts=''
    done
}
